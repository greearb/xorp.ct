#!/usr/bin/env python3
import sys, traceback, string, re
from time import time, localtime, strftime

# -----------------------------------------------------------------------------
# Utility methods and structures

def warn(file, lineno, reason):
    print("In Xrl starting at line {} in {}:\t{}".format(lineno, file, reason))

def quit(file, lineno, reason):
    warn(file, lineno, reason)
    traceback.print_stack()
    sys.exit(1)

def file_write_string(fname, data):
    f = open(fname, "w")
    ts = re.compile(r'[ \t]+$', re.MULTILINE)
    data = ts.sub("", data)
    f.write(data)
    f.close()

def file_append_string(fname, data):
    f = open(fname, "a")
    ts = re.compile(r'[ \t]+$', re.MULTILINE)
    data = ts.sub("", data)
    f.write(data)
    f.close()

def xorp_indent(level):
    if level <= 0:
        return ""
    s = ""
    ntabs = level // 2
    for i in range(0, ntabs):
        s += "\t"

    nspaces = level % 2
    if (nspaces):
        s += "    "
    return s

def xorp_indent_string(level, x):
    return xorp_indent(level) + x

def xorp_indent_list(level, list_arg):
    return [xorp_indent_string(level, x) for x in list_arg]

# Fix Xrl interface, method, and argument names for c++
def cpp_name(xrl_name):
    new_name = ""
    for i in range(0, len(xrl_name)):
        c = xrl_name[i]
        if (c == '/') or (c == '-') or (c == "."):
            c = "_"
        new_name += c
    return new_name

# Return service name given fully-qualified XRL name
def service_name_of_xrl(xrl_name):
    lfs = xrl_name.find('/')
    s = xrl_name[:lfs]
    return s

# Return method name given fully-qualified XRL name
def method_name_of_xrl(xrl_name):
    rfs = xrl_name.rfind('/')
    m = xrl_name[rfs+1:]
    return m

# Capitalize proper names
def proper(n):
    l = ' '
    r = ""
    for i in range(0, len(n)):
        if l in string.whitespace:
            r += n[i].upper()
        else:
            r += n[i].lower()
        l = n[i]
    return r

# Generate class name
def cpp_classname(s):
    return proper(s.replace("-", " ").replace("_", " ")).replace(" ", "").replace(".", "_")

# Generate a capitalized class name "dilbert_chaser" -> "DilbertChaser"
def caps_cpp_classname(s):
    apply_cap = 1
    r = ""
    for l in s:
        if l in string.digits:
            apply_cap = 1
        elif l not in string.ascii_letters:
            apply_cap = 1
            l = ''
        elif (apply_cap):
            l = l.upper()
            apply_cap = 0
        r += l
    return r

def cpp_version(v):
    # v looks like %d.%d
    return ("V" + v).replace(".", "p")

# Transform list of strings into a comma separated values string
def csv(l, comma = ", "):
    s = ''
    n = len(l)
    if (n >= 1):
        s = "%s" % l[0]
    for i in range(1,n):
        s += "%s%s" % (comma, l[i])
    return s;

# Transform list of strings into a comma separated values string suitable
# for appending to an existing comma separated value string.
def joining_csv(l, comma = ", "):
    s = ''
    n = len(l)
    for i in range(0,n):
        s += "%s%s" % (comma, l[i])
    return s;

# Extract $XORP line if exists
def get_xorp_cvs_id(filename):

    xorp_id = "$%s$" % "XORP"

    try:
        f = open(filename, "r")
    except:
        return xorp_id

    for line in f.readlines():
        mo = re.search(r"\$XORP.*\$", line)
        if mo != None:
            xorp_id = line[mo.start():mo.end()]
            break
    f.close()
    return xorp_id

# Generate standard header gubbins
def standard_preamble(is_header, filename):
    global g_source_files
    s = \
 """/*
 * %s
 * vim:set sts=4 ts=8 ft=cpp:
 *
 * Copyright (c) 2001-2011 XORP, Inc and Others
 * See the XORP LICENSE.lgpl file for licensing, conditions, and warranties
 * on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by '%s'.
""" % (filename, sys.argv[0][sys.argv[0].rfind("/") + 1:])

    #xorp_cvs_id = get_xorp_cvs_id(filename)
    #if is_header:
    #    s += " *\n * %s\n" % xorp_cvs_id

    s += " */\n\n"
    #if is_header == 0:
    #    s += "#ident \"%s\"\n\n" % xorp_cvs_id

    return s;

def xrl_method_name(ifname, version, if_methodname):
    return "%s/%s/%s" % (ifname, version, if_methodname)
