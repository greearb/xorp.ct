// -*- c-basic-offset: 4; tab-width: 8; indent-tabs-mode: t -*-

// Copyright (c) 2001,2002 International Computer Science Institute
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software")
// to deal in the Software without restriction, subject to the conditions
// listed in the XORP LICENSE file. These conditions include: you must
// preserve this copyright notice, and you cannot mention the copyright
// holders in advertising related to the Software without their permission.
// The Software is provided WITHOUT ANY WARRANTY, EXPRESS OR IMPLIED. This
// notice is a summary of the XORP LICENSE file; the license in that file is
// legally binding.

#ident "$XORP: xorp/libxipc/xrl_error.cc,v 1.2 2002/12/19 01:29:12 hodson Exp $"

#include <stdio.h>
#include <string>

#include "xrl_module.h"
#include "config.h"
#include "libxorp/xorp.h"
#include "libxorp/c_format.hh"

#include "config.h"
#include "xrl_error.hh"

class XrlErrlet {
public:
    XrlErrlet(uint32_t n, const char *s) : _error_code(n), _error_msg(s)
    {
	if (find(n)) abort(); // programming error, definitely
	_next = _errlet_head; // plumb in entry
	_errlet_head = this;
    }

    static const XrlErrlet* find(uint32_t error_code) {
	for (const XrlErrlet* e = _errlet_head; e != 0; e = e->_next) {
	    if (e->_error_code == error_code) return e;
	}
	return 0;
    }

    inline uint32_t    error_code() const { return _error_code; }
    inline const char* error_msg() const { return _error_msg; }

protected:
    const uint32_t _error_code;
    const char*	   _error_msg;

    // Node for list of all known errlets
    XrlErrlet*	   _next;
    // Head pointer for all known errlets
    static XrlErrlet* _errlet_head;
};

XrlErrlet* XrlErrlet::_errlet_head = 0;

// Macro that glues together XrlErrlet and XrlError
#define XRL_ERROR_GLUE(ename, oname, code, reason)			      \
static const XrlErrlet ename(code, reason); 				      \
static const XrlError E_##oname(&ename);				      \
const XrlError& XrlError::oname() { return E_##oname; }

// Dispatch Method Errors - generated by user callback
// NB BAD_ARGS and COMMAND_FAILED have additional magic at the end of this file
XRL_ERROR_GLUE(okay, OKAY, 100, "Okay");
XRL_ERROR_GLUE(bad_args, BAD_ARGS, 101, "Bad argument(s)");
XRL_ERROR_GLUE(command_failed, COMMAND_FAILED, 102, "Command failed");

// Transport Errors - generated by transport library
XRL_ERROR_GLUE(resolve_failed, RESOLVE_FAILED, 200, "Resolve failed");
XRL_ERROR_GLUE(no_finder, NO_FINDER, 201, "Finder not present/ready");

XRL_ERROR_GLUE(send_failed, SEND_FAILED, 210, "Transport failed");
XRL_ERROR_GLUE(reply_timed_out, REPLY_TIMED_OUT, 211, "Reply timed out");
XRL_ERROR_GLUE(no_such_method, NO_SUCH_METHOD, 212, "No such method");

XRL_ERROR_GLUE(corrupt_xrl, CORRUPT_XRL, 220, "Corrupt XRL");
XRL_ERROR_GLUE(corrupt_response, CORRUPT_RESPONSE, 221, "Corrupt response");
XRL_ERROR_GLUE(bad_protocol, BAD_PROTOCOL_VERSION, 222, "Bad protocol version");

XRL_ERROR_GLUE(syscall_failed, SYSCALL_FAILED, 230, "System call failed");

XRL_ERROR_GLUE(failed_unknown, FAILED_UNKNOWN, 911, "Failed unknown");

XrlError::XrlError() : _errlet(&okay) {}

XrlError::XrlError(const XrlErrlet* errlet) : _errlet(errlet) {}

XrlError::XrlError(uint32_t errcode, const string& note)
    : _note(note)
{
    _errlet = XrlErrlet::find(errcode);
    if (_errlet == 0) {
	_errlet = &failed_unknown;
	_note = c_format("Errorcode %d unknown", errcode);
	if (note.size()) {
	    _note += " " + note;
	}
    }
}

bool
XrlError::known_code(uint32_t errcode)
{
    return (XrlErrlet::find(errcode) != 0);
}

uint32_t
XrlError::error_code() const
{
    return _errlet->error_code();
}

const char*
XrlError::error_msg() const
{
    return _errlet->error_msg();
}
