/*
 * Copyright (c) 2001-2004 International Computer Science Institute
 * See LICENSE file for licensing, conditions, and warranties on use.
 *
 * DO NOT EDIT THIS FILE - IT IS PROGRAMMATICALLY GENERATED
 *
 * Generated by 'clnt-gen'.
 */

#ident "$XORP$"

#include "fea_click_xif.hh"

bool
XrlFeaClickV0p1Client::send_enable_click(
	const char*	the_tgt,
	const bool&	enable,
	const EnableClickCB&	cb
)
{
    Xrl x(the_tgt, "fea_click/0.1/enable_click");
    x.args().add("enable", enable);
    return _sender->send(x, callback(this, &XrlFeaClickV0p1Client::unmarshall_enable_click, cb));
}


/* Unmarshall enable_click */
void
XrlFeaClickV0p1Client::unmarshall_enable_click(
	const XrlError&	e,
	XrlArgs*	a,
	EnableClickCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFeaClickV0p1Client::send_start_click(
	const char*	the_tgt,
	const StartClickCB&	cb
)
{
    Xrl x(the_tgt, "fea_click/0.1/start_click");
    return _sender->send(x, callback(this, &XrlFeaClickV0p1Client::unmarshall_start_click, cb));
}


/* Unmarshall start_click */
void
XrlFeaClickV0p1Client::unmarshall_start_click(
	const XrlError&	e,
	XrlArgs*	a,
	StartClickCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFeaClickV0p1Client::send_stop_click(
	const char*	the_tgt,
	const StopClickCB&	cb
)
{
    Xrl x(the_tgt, "fea_click/0.1/stop_click");
    return _sender->send(x, callback(this, &XrlFeaClickV0p1Client::unmarshall_stop_click, cb));
}


/* Unmarshall stop_click */
void
XrlFeaClickV0p1Client::unmarshall_stop_click(
	const XrlError&	e,
	XrlArgs*	a,
	StopClickCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFeaClickV0p1Client::send_set_click_config_generator_file(
	const char*	the_tgt,
	const string&	click_config_generator_file,
	const SetClickConfigGeneratorFileCB&	cb
)
{
    Xrl x(the_tgt, "fea_click/0.1/set_click_config_generator_file");
    x.args().add("click_config_generator_file", click_config_generator_file);
    return _sender->send(x, callback(this, &XrlFeaClickV0p1Client::unmarshall_set_click_config_generator_file, cb));
}


/* Unmarshall set_click_config_generator_file */
void
XrlFeaClickV0p1Client::unmarshall_set_click_config_generator_file(
	const XrlError&	e,
	XrlArgs*	a,
	SetClickConfigGeneratorFileCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFeaClickV0p1Client::send_enable_kernel_click(
	const char*	the_tgt,
	const bool&	enable,
	const EnableKernelClickCB&	cb
)
{
    Xrl x(the_tgt, "fea_click/0.1/enable_kernel_click");
    x.args().add("enable", enable);
    return _sender->send(x, callback(this, &XrlFeaClickV0p1Client::unmarshall_enable_kernel_click, cb));
}


/* Unmarshall enable_kernel_click */
void
XrlFeaClickV0p1Client::unmarshall_enable_kernel_click(
	const XrlError&	e,
	XrlArgs*	a,
	EnableKernelClickCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFeaClickV0p1Client::send_enable_user_click(
	const char*	the_tgt,
	const bool&	enable,
	const EnableUserClickCB&	cb
)
{
    Xrl x(the_tgt, "fea_click/0.1/enable_user_click");
    x.args().add("enable", enable);
    return _sender->send(x, callback(this, &XrlFeaClickV0p1Client::unmarshall_enable_user_click, cb));
}


/* Unmarshall enable_user_click */
void
XrlFeaClickV0p1Client::unmarshall_enable_user_click(
	const XrlError&	e,
	XrlArgs*	a,
	EnableUserClickCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFeaClickV0p1Client::send_set_user_click_command_file(
	const char*	the_tgt,
	const string&	user_click_command_file,
	const SetUserClickCommandFileCB&	cb
)
{
    Xrl x(the_tgt, "fea_click/0.1/set_user_click_command_file");
    x.args().add("user_click_command_file", user_click_command_file);
    return _sender->send(x, callback(this, &XrlFeaClickV0p1Client::unmarshall_set_user_click_command_file, cb));
}


/* Unmarshall set_user_click_command_file */
void
XrlFeaClickV0p1Client::unmarshall_set_user_click_command_file(
	const XrlError&	e,
	XrlArgs*	a,
	SetUserClickCommandFileCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFeaClickV0p1Client::send_set_user_click_command_extra_arguments(
	const char*	the_tgt,
	const string&	user_click_command_extra_arguments,
	const SetUserClickCommandExtraArgumentsCB&	cb
)
{
    Xrl x(the_tgt, "fea_click/0.1/set_user_click_command_extra_arguments");
    x.args().add("user_click_command_extra_arguments", user_click_command_extra_arguments);
    return _sender->send(x, callback(this, &XrlFeaClickV0p1Client::unmarshall_set_user_click_command_extra_arguments, cb));
}


/* Unmarshall set_user_click_command_extra_arguments */
void
XrlFeaClickV0p1Client::unmarshall_set_user_click_command_extra_arguments(
	const XrlError&	e,
	XrlArgs*	a,
	SetUserClickCommandExtraArgumentsCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFeaClickV0p1Client::send_set_user_click_command_execute_on_startup(
	const char*	the_tgt,
	const bool&	user_click_command_execute_on_startup,
	const SetUserClickCommandExecuteOnStartupCB&	cb
)
{
    Xrl x(the_tgt, "fea_click/0.1/set_user_click_command_execute_on_startup");
    x.args().add("user_click_command_execute_on_startup", user_click_command_execute_on_startup);
    return _sender->send(x, callback(this, &XrlFeaClickV0p1Client::unmarshall_set_user_click_command_execute_on_startup, cb));
}


/* Unmarshall set_user_click_command_execute_on_startup */
void
XrlFeaClickV0p1Client::unmarshall_set_user_click_command_execute_on_startup(
	const XrlError&	e,
	XrlArgs*	a,
	SetUserClickCommandExecuteOnStartupCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFeaClickV0p1Client::send_set_user_click_control_address(
	const char*	the_tgt,
	const IPv4&	user_click_control_address,
	const SetUserClickControlAddressCB&	cb
)
{
    Xrl x(the_tgt, "fea_click/0.1/set_user_click_control_address");
    x.args().add("user_click_control_address", user_click_control_address);
    return _sender->send(x, callback(this, &XrlFeaClickV0p1Client::unmarshall_set_user_click_control_address, cb));
}


/* Unmarshall set_user_click_control_address */
void
XrlFeaClickV0p1Client::unmarshall_set_user_click_control_address(
	const XrlError&	e,
	XrlArgs*	a,
	SetUserClickControlAddressCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFeaClickV0p1Client::send_set_user_click_control_socket_port(
	const char*	the_tgt,
	const uint32_t&	user_click_control_socket_port,
	const SetUserClickControlSocketPortCB&	cb
)
{
    Xrl x(the_tgt, "fea_click/0.1/set_user_click_control_socket_port");
    x.args().add("user_click_control_socket_port", user_click_control_socket_port);
    return _sender->send(x, callback(this, &XrlFeaClickV0p1Client::unmarshall_set_user_click_control_socket_port, cb));
}


/* Unmarshall set_user_click_control_socket_port */
void
XrlFeaClickV0p1Client::unmarshall_set_user_click_control_socket_port(
	const XrlError&	e,
	XrlArgs*	a,
	SetUserClickControlSocketPortCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}

bool
XrlFeaClickV0p1Client::send_set_user_click_startup_config_file(
	const char*	the_tgt,
	const string&	user_click_startup_config_file,
	const SetUserClickStartupConfigFileCB&	cb
)
{
    Xrl x(the_tgt, "fea_click/0.1/set_user_click_startup_config_file");
    x.args().add("user_click_startup_config_file", user_click_startup_config_file);
    return _sender->send(x, callback(this, &XrlFeaClickV0p1Client::unmarshall_set_user_click_startup_config_file, cb));
}


/* Unmarshall set_user_click_startup_config_file */
void
XrlFeaClickV0p1Client::unmarshall_set_user_click_startup_config_file(
	const XrlError&	e,
	XrlArgs*	a,
	SetUserClickStartupConfigFileCB		cb
)
{
    if (e != XrlError::OKAY()) {
	cb->dispatch(e);
	return;
    } else if (a && a->size() != 0) {
	XLOG_ERROR("Wrong number of arguments (%u != %u)", (uint32_t)a->size(), 0);
	cb->dispatch(XrlError::BAD_ARGS());
	return;
    }
    cb->dispatch(e);
}
