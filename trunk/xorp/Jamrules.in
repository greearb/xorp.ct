#
# $XORP: xorp/Jamrules.in,v 1.6 2007/04/12 10:03:14 bms Exp $
#

# TODO: Obey LOCATE_TARGET for building XORP from a directory
# other than the source directory.

NotFile install ;

#
# Stuff obtained from ./configure script.
#
PREFIX		= @prefix@ ;
CC 		= @CC@ ;
C++		= @CXX@ ;
#CPP		= @CPP@ ;	# not used by jam [yet]
#CXXCPP		= @CXXCPP@ ;	# not used by jam [yet]
CCFLAGS		= @CFLAGS@ ;
C++FLAGS	= @CXXFLAGS@ ;
LINKFLAGS	= @LDFLAGS@ ;
CLI_CURSES_LIB	= @CLI_CURSES_LIB@ ;

#
# PYTHON_DEFINED will be substituted with a comment character if configure
# did not define PYTHON for us; however, the automake macros prefer to
# substitute a colon character. Detect both situations and make sure that
# the build fails with a meaningful error message if either case arises.
# 
AC_PYTHON	= @PYTHON@ ;
PYTHON_DEFINED	= @PYTHON_BUILD@ defined
		; # This semicolon must be on a new line.
if ( ! $(PYTHON_DEFINED) || $(AC_PYTHON) = \: )
{
 PYTHON = false ;
}

# failsafe
CRYPTO_LIB	?= -lcrypto ;

# top level stuff
HDRS		 = . $(SEARCH_SOURCE) $(TOP) ;
EXEMODE		 = 755 ;
LINKLIBS	+= $(CRYPTO_LIB) $(CLI_CURSES_LIB) ;

# If GNU C++ is used, it must be used as the linker.
if $(C++) = "g++"
{
 LINK = $(C++) ;
}

#
# Win32 failsafe overrides; only really applicable for mingw gcc.
# TODO: Support Microsoft Visual C++ when JAM_TOOLSET is VISUALC.
#
if $(OS) = "NT"
{
# XXX: -Werror has been removed for now due to spurious warnings
 CCFLAGS =  -g -W -Wall -Wwrite-strings -Wbad-function-cast -Wmissing-prototypes -Wcast-qual -Wmissing-declarations -Wpointer-arith -Wcast-align -Wstrict-prototypes -Wnested-externs -pipe ;
 C++FLAGS = -g -W -Wall -Wwrite-strings -Wcast-qual -Wpointer-arith -Wcast-align -Woverloaded-virtual -ftemplate-depth-25 -pipe ;
#
PYTHON		?= python ;
HDRS		 = . $(SEARCH_SOURCE) $(TOP) /mingw/include ;
DEFINES		 = _NO_OLDNAMES MPR50=1 ;
LINKFLAGS	+= -mconsole ;
CLI_CURSES_LIB	 = ;
CRYPTO_LIB	 = -lcrypto ;
LINKLIBS	+= -lpcreposix -lws2_32 -liphlpapi -lmprapi -ladvapi32 ;
}

# XXX FIXME: MIBS
#NETSNMPCFLAGS = -DINET6 -O2 -fno-strict-aliasing -pipe -Dfreebsd6 -DAPPLLIB_EXP=/usr/local/lib/perl5/5.8.8/BSDPAN -DHAS_FPSETMASK -DHAS_FLOATINGPOINT_H -fno-strict-aliasing -pipe -I/usr/local/include -I/usr/local/lib/perl5/5.8.8/mach/CORE -I. -I/usr/local/include -I.. ;

############################################################################
#
# XORP project custom rules follow.
#
# TODO: double check flex version: $(FLEX), version contingent.
# TODO: double check yacc version: $(YACC), not bison, version contingent.

#
# Variables used by XORP custom build.
#
SCRIPT_DIR = $(TOP)/xrl/scripts ;
INTERFACES_DIR = $(TOP)/xrl/interfaces ;
TARGET_DIR = $(TOP)/xrl/targets ;

CLNTGEN_PY = $(SCRIPT_DIR)/clnt-gen ;
TGTGEN_PY = $(SCRIPT_DIR)/tgt-gen ;

XYACC = yacc ;
XFLEX = flex ;

############################################################################
#
# XorpSplitLibrary
# Usage: XorpSplitLibrary libtarget : defs : suffix : sources ;
#
# Build a library from a given set of sources, using the user's
# provided DEFINES, appending 'suffix' to the names of the objects
# to avoid clobbering a library built using different DEFINES.
# 
# The library so built may then be referenced as a Library target
# from elsewhere within the tree.
# This is used to build RIP for IPv4 and IPv6 from the same sources.
#
rule XorpSplitLibrary
{
  local _sufobj ;
  _sufobj = "-$(3)$(SUFOBJ)" ;
  LibraryFromObjects $(1) : $(4:S=$(_sufobj)) ;
  XorpSplitObjects $(2) : $(_sufobj) : $(4) ;
}

############################################################################
#
# XorpSplitObjects
# Usage: XorpSplitObjects defs : sufobj : sources ;
#
# Build a bunch of objects with a given suffix in the filename and
# a given set of DEFINES.
# For internal use only by the XorpSplitLibrary rule.
#
rule XorpSplitObjects
{
  local _i ;

  for _i in [ FGristFiles $(3) ]
  {
    DEFINES on $(_i:S=$(2)) += $(1) ;
    Object $(_i:S=$(2)) : $(_i) ;
    Depends obj : $(_i:S=$(2)) ;
  }
}

############################################################################
#
# XorpXrlXif
# Usage: XorpXrlXif <path!grist>foo.cc <p!g>foo.hh : foo.xif ;
#
# Generate XRL interface stubs.
# Use 'jam xrlclean' to remove generated code.
#
# XXX: TODO: Pass environment variable to clnt-gen under Win32 to
# tell it it's being run from Jam and DTRT with paths.
#
rule XorpXrlXif
{
 local _cc ;
 local _hh ;

 if $(PYTHON) = false
 { 
   Exit "Python was not detected, and is required to rebuild XRLs. Aborting." ;
 }

 SEARCH on $(>) = $(SEARCH_SOURCE) ;	# source .xif file
 MakeLocate $(<) : $(LOCATE_SOURCE) ;	# generated sources

 _cc = $(<[1]) ;
 _hh = $(<[2]) ;

 Includes $(_cc) : $(_hh) ;
 DEPENDS $(<) : $(>) ;

 Clean reallyclean : $(<) ;
}
actions XorpXrlXif
{
 $(PYTHON) $(CLNTGEN_PY) $(>)
}

############################################################################
#
# XorpXrlTgt
# Usage: XorpXrlTgt <path!grist>foo.cc <p!g>foo.hh <p!g>foo.xrls : foo.tgt ;
#
# Generate XRL target stubs and headers.
# Use 'jam xrlclean' to remove generated code.
#
# XXX: TODO: Pass environment variable to clnt-gen under Win32 to
# tell it it's being run from Jam and DTRT with paths.
#
rule XorpXrlTgt
{
 local _cc ;
 local _hh ;
 local _xrls ;

 if $(PYTHON) = false
 { 
   Exit "Python was not detected, and is required to rebuild XRLs. Aborting." ;
 }

 SEARCH on $(>) = $(SEARCH_SOURCE) ;	# source .tgt file
 MakeLocate $(<) : $(LOCATE_SOURCE) ;	# generated sources

 _cc = $(<[1]) ;
 _hh = $(<[2]) ;
 _xrls = $(<[3]) ;

 HDRRULE on $(>) = HdrRule ;
 HDRSCAN on $(>) = $(HDRPATTERN) ;
 HDRSEARCH on $(>) = $(SEARCH_SOURCE:E) $(SUBDIRHDRS) $(HDRS) $(STDHDRS) ;
 HDRGRIST on $(>) = $(HDRGRIST) ;

 Includes $(_cc) : $(_hh) ;
 DEPENDS $(<) : $(>) ;

 # problems with this on win32:
 #Includes $(_cc) : $(_xrls) ; # lie to squelch warning
 #DEPENDS install : $(_xrls) ; # the correct dependency

 Clean xrlclean : $(<) ;
}
actions XorpXrlTgt
{
 $(PYTHON) $(TGTGEN_PY) -I$(INTERFACES_DIR) $(>)
}

############################################################################
#
# XorpYaccC++
# Usage:  XorpYaccC++ ccfile : hfile : prefix : yaccfile ;
#
# Generate C++ source and headers from a Yacc C++ parser description file.
#
# This rule should be braced within a conditional when used, so as to
# avoid building them automatically.
# Use 'jam reallyclean' to remove generated code.
# An intermediate file rename is needed because of how yacc names its
# output files. The XORP policy code does not perpetuate this kludge.
#
rule XorpYaccC++
{
 local _yy = $(4) ;

 SEARCH on $(_yy) = $(SEARCH_SOURCE) ;		# source .yy file
 MakeLocate $(1) $(2) : $(LOCATE_SOURCE) ;	# generated sources

 XYACCFLAGS on $(<) = "-d -p $(3)" ;
 XorpYaccC++Mv1 $(<) : $(_yy) ;

 Includes $(<) : $(2) ;		# real
 DEPENDS $(<) : $(_yy) ;	# real
 DEPENDS $(3) : $(_yy) ;	# dummy
 DEPENDS $(<) : $(3) ;		# dummy

 Clean reallyclean : $(<) $(2) ;
}
actions XorpYaccC++Mv1
{
 $(XYACC) $(XYACCFLAGS) -o $(<:BS=.c) $(>)
 $(MV) $(<:BS=.c) $(<)
}

############################################################################
#
# XorpFlexC++
# Usage:  XorpFlexC++ ccfile : prefix : lexfile ;
#
# Generate C++ source from a Flex C++ lexer description file (.ll).
# This rule should be braced within a conditional when used, so as to
# avoid building them automatically.
# Use 'jam reallyclean' to remove generated code.
#
rule XorpFlexC++
{
 local _ll = $(3) ;

 SEARCH on $(_ll) = $(SEARCH_SOURCE) ;	# source .ll file
 #MakeLocate $(<) : $(LOCATE_SOURCE) ;	# generated sources

 DEPENDS $(<) : $(_ll) ;	# real
 DEPENDS $(2) : $(_ll) ;	# dummy
 DEPENDS $(<) : $(2) ;		# dummy

 XFLEXFLAGS on $(<) = "-P$(2)" ;
 XorpFlexC++1 $(<) : $(_ll) ;

 Clean reallyclean : $(<) ;
}
actions XorpFlexC++1
{
 $(XFLEX) $(XFLEXFLAGS) -o$(<) $(>)
}

############################################################################
#
# SubIncludeOnce
# Usage: SubIncludeOnce TOP dirname .. dirn ;
#
# This rule should be used to make sure each Jamfile is referenced only
# once from any other part of the tree. This is the magic which makes
# possible Jam's graph-recursive, rather than tree-recursive, builds.
#
rule SubIncludeOnce
{
    local includepath = [ FDirName $(<[2-]) ] ;
    local path = $(includepath:R=$($(<[1]))) ;

    if ! $($(path)-subinclude)
    {
        # not included before, so do it now.
        $(path)-subinclude = TRUE ;
        if $(VERBOSE)
        {
            ECHO "SubInclude: including" $(JAMFILE:D=$(path)) ;
        }
        include $(JAMFILE:D=$(path)) ;
    }
    else
    {
        if $(VERBOSE)
        {
            ECHO "SubInclude: already included" $(JAMFILE:D=$(path)) ;
        }
    }
}

############################################################################
#
# XorpUnitTests
# Usage: XorpUnitTests test_foo .. test_bar ;
#
# Rudimentary support for running regression tests.
# Strictly UNIX only for the time being.
# Use jam -sRUN_CHECK=1 check to use this.
#
rule XorpUnitTests
{
 if $(RUN_CHECK) {
	#NOTFILE check ;

	local thisdir = $(SEARCH_SOURCE) ;
	SEARCH on $(<) = $(SEARCH_SOURCE) ;
	#SEARCH on $(<) = $(LOCATE_TARGET) ;	# XXX should really use this

	ECHO "XorpUnitTests: executing tests in" $(thisdir) ;

	DEPENDS check : $(<) ;
	ALWAYS $(<) ;

	for test-file in $(<)
	{
		ECHO "XorpUnitTests: executing" $(test-file) ;
		SEARCH on $(test-file) = $(SEARCH_SOURCE) ;
		XorpUnitTest1 $(test-file) ;
	}
 }
}
actions piecemeal XorpUnitTest1
{
	PATH="$PATH:."
	$(<)
}

############################################################################
#
# GMake
# Usage: GMake gmakefiletarget ;
#
# This is a special rule and action to invoke gmake from within a directory.
# PLEASE AVOID USING GMAKE AS IT CAN POTENTIALLY BREAK PARALLELIZED BUILDS.
# Previously used to build libtecla.
#
#GMAKE ?= gmake ;
#rule GMake
#{
#	if $(GMAKE)
#	{
#		SEARCH on $(<) = $(SEARCH_SOURCE) ;
#		LOCATE on $(<) = $(SEARCH_SOURCE) ;
#		GMake1 $(<) : $(>) ;
#	}
#	# Should print an error if gmake is not found.
#}
#actions GMake1
#{
#	$(GMAKE) -C $(SEARCH) $(>)
#}

############################################################################
#
# With Jam/MR, the UserObject rule may be overridden to extend Jam's
# behaviour. This is Jam's analogue to make's built-in suffix rules.
#
# These are special UserObject rules which allow us to declare dependencies
# directly on the .xrl and .tgt files used to describe the XRLs when
# defining Library targets.
#
# Due to how the UserObject rule works in Jam, the intermediate object
# files which are generated by the suffix rules will not contain the
# _base or _xif suffixes which they did in the Automake-based build.
#
# Unfortunately this makes life difficult if we need to reference the
# objects or source files themselves from outside their subtrees...
# ...but it does make building all the xrl stubs very easy!
#
# Because we need the intermediate nodes on that part of the dependency
# graph from elsewhere in the tree, we don't use UserObject to build
# the XRL stubs; we use custom rules defined elsewhere in this file.
#
#rule UserObject
#{
# switch $(>) {
# case *.xif :	Object $(>:S=_xif.o) : $(<:S=_xif.cc) ;
#		XorpXrlXif $(<:S=_xif.cc) $(<:S=_xif.hh) : $(>) ;
# case *.tgt :	Object $(<) : $(<:S=_base.cc) ;
#		XorpXrlTgt $(<:S=_base.cc) : $(>) ;
# case * :	ECHO "unknown suffix on" $(>) ;
# }
#}

############################################################################
#
# The following rules are lifted from FTJam's Jambase file, for UNIX
# only, and have been prefixed with a Z.
#

SUFOBJSHR   ?= .lo ;
SUFLIBSHR   ?= .la ;
PICFLAGS    ?= -fpic ;

# /ZSharedLibrary  library : sources : def : import ;
#
# Compiles _sources_ and generates a shared _library_ (i.e. DLL on Windows,
# or shared object on Unix). Calls @ZSharedObjects and @ZSharedLibraryFromObjects
#
# If @ZSharedLibrary is invoked with no suffix on _library_, then
# $(SUFLIBSHR) suffix is used
#
# _def_ is the name of the corresponding definition file used to generate
# the library on Windows and OS/2 (ignored otherwise). If undefined, it
# will default to _library_ with the .def suffix
#
# _import_ is the name of the corresponding import library for Windows
# and OS/2 platforms (ignored otherwise). If undefined, it will default
# to _library_ with the .dll.lib suffix.
#
rule ZSharedLibrary
{
  ZSharedLibraryFromObjects $(<) : $(>:S=$(SUFOBJSHR)) : $(3) : $(4) ;
  ZSharedObjects            $(>) ;
}

if $(UNIX)
{
  # this rule is used to find the 'libtool' script in the current
  # path, this is required when compiling shared objects on Unix
  #
  rule ZLibToolFind
  {
    if $(LIBTOOL) { return $(LIBTOOL) ; }

    local  matches = [ Glob $(PATH) : libtool ] ;

    if ! $(matches)
    {
      Exit "could not find 'libtool' program in current path. Aborting !" ;
    }
    LIBTOOL = $(matches[1]) ;

    return $(LIBTOOL) ;
  }
}

# /SharedLibraryFromObjects  library : objects : def : import ;
#
# Equivalent of @LibraryFromObjects for shared libraries.
#
# Called by @SharedLibrary. Most people shouldn't call this rule
# directly
#
# XXX This currently doesn't seem to do anything.. and needs fixing!
rule ZSharedLibraryFromObjects
{
    local _i _l _lg _s ;

    # Add grist to file names
    _s = [ FGristFiles $(>) ] ;
    _l = $(<:S=$(SUFLIBSHR)) ; # XXX: not gristed
    _lg = [ FGristFiles $(_l) ] ;

    Echo "Library is $(_l)"    ;
    Echo "Library gristed is $(_lg)"    ;
    # library depends on its member objects

    if $(KEEPOBJS)
    {
      Depends obj : $(_s) ;
    }
    else
    {
      Depends lib : $(_l) ;
    }

    # Set LOCATE for the library and its contents.  The bound
    # value shows up as $(NEEDLIBS) on the Link actions.
    # For compatibility, we only do this if the library doesn't
    # already have a path.

    if ! $(_l:D)
    {
        MakeLocate $(_l) : $(LOCATE_TARGET) ;
    }

    # we never scan shared libraries for member objects
    Depends $(_l) : $(_s) ;

    Clean clean : $(_l) ;

    # I don't know if VMS supports shared libraries, so I prefer
    # to disable the following right now
    #
    #if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }

    # creating the library is so much fun on Unix :-)
    if $(UNIX)
    {
      #local  libtool = [ ZLibToolFind ] ;  # find the right libtool
      LIBTOOL = [ ZLibToolFind ] ;  # find the right libtool
      # XXX grist?
      #AR on $(_l) = "$(LIBTOOL) --mode=link $(AR)" ;
      AR on $(_lg) = "$(LIBTOOL) --mode=link $(AR)" ;
    } else {
      Echo "Sorry, I don't know how to make a shared library on your system" ;
      Exit "Please contact the FTJam maintainer for help" ;
    }
}

# /ZSharedObjects
#
# this rule is used to compile one or more sources into 'shared object
# files'. This means object files used to build either DLLs or Unix shared
# libraries.
#
# do not call this rule directly, it is called by SharedLibrary automatically
#
# XXX: This is considerably hacked from ftjam's version,
# and appears to invoke libtool and build the .lo's
# correctly (at least on FreeBSD) -bms
#
rule ZSharedObjects
{
  # temporarily override SUFOBJ with $(SUFOBJSHR)
  local SUFOBJ = $(SUFOBJSHR) ;
  # XXX: Explicit grist seems to be needed here.
  local gristed = [ FGristFiles $(<:S=$(SUFOBJSHR)) ] ;

  Objects $(<) ;

  # Change the compiler invocation for all these objects
  # to use libtool on UNIX-like systems.
  # We explicitly disable the generation of static objects here.
  if $(UNIX)
  {
   # XXX: Can't make this local; it doesn't propagate otherwise
   LIBTOOL = [ ZLibToolFind ] ;
   #ECHO "libtool is" $(libtool) ;
   CC on $(gristed) = "$(LIBTOOL) --mode=compile $(CC) -shared" ;
   C++ on $(gristed) = "$(LIBTOOL) --mode=compile $(C++) -shared" ;
  } else {
   # building without libtool; flags explicitly required
   CCFLAGS on $(gristed) += $(PICFLAGS) ;
   C++FLAGS on $(gristed) += $(PICFLAGS) ;
  }
}

# /LinkSharedLibraries image : libraries :
#
# Same as @LinkLibraries, but to link _image_ with shared libraries
# generated through the @SharedLibrary rule
#
rule ZLinkSharedLibraries
{
    # make library dependencies of target
    # set NEEDLIBS variable used by 'actions Main'

    local _t   = [ FAppendSuffix $(<) : $(SUFEXE) ] ;
    local _ext = $(SUFLIBSHR) ;

    Depends $(_t) : $(>:S=$(_ext))  ;
    NEEDLIBS on $(_t) += $(>:S=$(_ext)) ;
}
